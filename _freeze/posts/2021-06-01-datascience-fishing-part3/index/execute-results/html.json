{
  "hash": "5c23cdce721ec5724c980220d3067abf",
  "result": {
    "markdown": "---\ntitle: \"Can R and Shiny make me a better fisherman? Part 3\"\nsubtitle: \"Updating my application\"\nauthor: \"Aurélien Callens\"\ndate: \"2021-06-01\"\ntoc: true\nexecute:\n  eval: false\ncategories:\n  - R\n  - Shiny\n  - Web scraping\n---\n\n\n\n\n\nIn this [previous post](../../posts/2020-09-12-datascience-fishing-part1), I presented the shiny application I developed to record data about my fishing session. In today's post, I will present briefly the changes and updates I made to improve the application. Here are the main changes: \n\n\n+ **Weather API**: the API I was using (Dark Sky) stopped furnishing free data. I changed for [Openweathermap](https://openweathermap.org/) and I needed to update the functions to gather the same information as before.\n\n+ **River flow**: the first version of the application did not collect any data about the flow of the river in which I am fishing. However I am convinced that the river flow before the fishing session might have an impact on the presence of seabass. I therefore created a web scrapping function that collect the flow of the Nive and the Adour (main fishing rivers). \n\n+ **Collecting lure data**: in the first version, data about fishing lures I used were only collected when a fish was caught. However I did not have data about how long I used the lure before catching a fish. The new version of the application now collects data about lure and how often I change lure. \n\n## Weather API\n\nSmall changes were made to adapt the former weather function to the new weather API. As this new API do not furnish moon phase data, I decided to compute the moon phase with the *oce* package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(tidyverse)\nlibrary(rvest)\nlibrary(oce)\n\nweather <- function(lat, lon, API_key){\n  url <- paste0(\"api.openweathermap.org/data/2.5/weather?lat=\", lat, \"&lon=\", lon, \"&appid=\", API_key, \"&units=metric\")\n  \n  rep <- GET(url)\n  \n  table <- fromJSON(content(rep, \"text\"))\n  \n  # The weather API don't provide moon phase so I compute it with Oce package\n  moon_phase <- round(moonAngle(t = Sys.Date(),\n                                longitude = as.numeric(lon),\n                                latitude = as.numeric(lat))$illuminatedFraction,\n                      3)\n  \n  \n  current.weather.info <- data.frame(Air_temp = table$main$temp,\n                                     Weather = table$weather$main,\n                                     Atm_pres = table$main$pressure,\n                                     Wind_str = table$wind$speed,\n                                     Wind_dir = table$wind$deg,\n                                     Cloud_cover = table$clouds$all,\n                                     PrecipInt = ifelse(is.null(table$rains$`1h`), 0, table$rains$`1h`),  \n                                     Moon = moon_phase)\n  return(current.weather.info)\n}\n```\n:::\n\n\n## River flow\n\nI wrote functions to scrap information about the flows of the rivers in which I fish the most on a french website:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get and prepare the flow data\nget_Qdata <- function(link){\n  table <- fromJSON(content(GET(link), \"text\"))\n  table <- table$Serie$ObssHydro\n  table <- as.data.frame(table)\n  table$DtObsHydro <- sub(\"T\", \" \", table$DtObsHydro)\n  table$DtObsHydro <- substr(table$DtObsHydro, start = 1, stop = 19)\n  ts <- data.frame(Date = seq.POSIXt(as.POSIXct(range(table$DtObsHydro)[1],'%m/%d/%y %H:%M:%S'), \n                                     as.POSIXct(range(table$DtObsHydro)[2],'%m/%d/%y %H:%M:%S'), by=\"hour\"))\n  \n  table$DtObsHydro <- as.POSIXct(table$DtObsHydro, format = \"%Y-%m-%d %H:%M:%S\")\n  \n  table <- full_join(table, ts, by = c(\"DtObsHydro\" = \"Date\")) %>% arrange(DtObsHydro)\n  return(table)\n}\n\n# Main function to collect river flow \n\nriver_flow <- function(){\n  # Url of website to scrap:\n  url_index <- \"https://www.vigicrues.gouv.fr/services/station.json/index.php\"\n  \n  rep <- GET(url_index)\n  \n  table_index <- fromJSON(content(rep, \"text\"))$Stations%>% \n    na.omit()\n  \n  # I need to add the flow of several rivers to get the flow of the rivers I am interested in:\n  stations <- table_index %>% \n    filter(LbStationHydro %in% c(\"Pontonx-sur-l'Adour\", \"St-Pandelon\", \"Artiguelouve\", \"Escos\",\n                                 \"Aïcirits [St-Palais]\", \"Cambo-les-Bains\"))\n  \n  base_url <- \"http://www.vigicrues.gouv.fr/services/observations.json?CdStationHydro=\"\n  height_url <- \"&FormatDate=iso\"\n  Q_url <- \"&GrdSerie=Q\"\n  \n  stations <- stations %>% \n    mutate(WL_link = paste0(base_url, CdStationHydro, height_url),\n           Q_link = paste0(WL_link, Q_url))\n  \n  data_Q <- lapply(stations$Q_link, \n                   function(x){get_Qdata(x)})\n  \n  data_Q <- suppressWarnings(Reduce(function(...) merge(..., all = TRUE, by = \"DtObsHydro\"),\n                   data_Q))\n  \n  names(data_Q) <- c(\"Date\", stations$LbStationHydro) \n  \n  data_Q <- data_Q  %>% \n    mutate(hour_of_day = format(Date, \"%Y-%m-%d %H\"))\n  \n  \n  data_Q <- aggregate(.~hour_of_day, data = data_Q, mean, na.rm = TRUE, na.action = na.pass)\n  \n  data_Q <- imputeTS::na_interpolation(data_Q, option = \"linear\")\n  \n  final_data <- data_Q %>% \n    mutate(Adour = `Pontonx-sur-l'Adour` +  `Aïcirits [St-Palais]` + Artiguelouve + Escos + `St-Pandelon`,\n           Date = as.POSIXct(hour_of_day, tryFormats = \"%Y-%m-%d %H\")) %>% \n    select(Date, `Cambo-les-Bains`, Adour) %>% \n    rename(Nive = `Cambo-les-Bains`)\n  \n  Cur_flow <- data.frame(\"Nive_c\" = final_data[nrow(final_data), 2],\n                         \"Adour_c\" = final_data[nrow(final_data), 3])\n  \n  \n  final_data <- cbind(Cur_flow, final_data) %>% \n    nest(Ts_flow = c(Date, Nive, Adour)) %>% \n    mutate(Ts_flow = paste(Ts_flow))\n\n  return(final_data)\n}\n```\n:::\n\n\n## Shiny application \n\nA simplified graph of the new application is showed below: \n\n\n\n\n\n![Simplified workflow of the new version of application](images/graph_newapp.svg)\n\n\n### UI side\n\nThe UI side did not change that much, I only removed the tab that displayed fishing data on a map because I wasn't using this feature too much: \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load libraries \nlibrary(shiny)\nlibrary(shinyWidgets)\nlibrary(googlesheets)\nlibrary(miniUI)\nlibrary(leaflet)\nlibrary(rdrop2)\nSys.setenv(TZ=\"Europe/Paris\")\n\n#Import the functions for weather API and webscrapping \nsuppressMessages(source(\"api_functions.R\"))\n\n\n# Load the dropbox token : \ntoken <<- readRDS(\"token.rds\")\n\n# Minipage for small screens\nui <- miniPage(tags$script('$(document).ready(function () {\n                           navigator.geolocation.getCurrentPosition(onSuccess, onError);\n\n                           function onError (err) {\n                           Shiny.onInputChange(\"geolocation\", false);\n                           }\n\n                           function onSuccess (position) {\n                           setTimeout(function () {\n                           var coords = position.coords;\n                           console.log(coords.latitude + \", \" + coords.longitude);\n                           Shiny.onInputChange(\"geolocation\", true);\n                           Shiny.onInputChange(\"lat\", coords.latitude);\n                           Shiny.onInputChange(\"long\", coords.longitude);\n                           }, 1100)\n                           }\n                           });'),\n               \n               gadgetTitleBar(\"Catch them all\", left = NULL, right = NULL),\n               \n               miniTabstripPanel(\n                 \n                 miniTabPanel(\"Session\", icon = icon(\"sliders\"),\n                              \n                              miniContentPanel(uiOutput(\"UI_sess\", align = \"center\"),\n                                               uiOutput(\"UI\", align = \"center\"))\n                              \n                 )\n               )\n               \n)\n```\n:::\n\n\n### Server side\n\nSeveral changes were made in the server side to collect data about the lures I used. Now, each time I change my fishing lure, I fill a small form to collect the lure characteristics and it adds a line in a third csv file:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nserver <- function(input, output, session){\n  \n  observeEvent(input$go ,{\n    \n  # Read the csv file containing information about fishing session. If a session is running,\n  # display the UI that allows the user to input data about the fish caught. If a session is not started,\n  # display a button to start the session and small survey on lure characteristics.\n    \n    dat <<- drop_read_csv(\"/app_peche/session1.csv\", header = T, stringsAsFactors = F, dtoken = token)\n    \n    # Reactive UI\n    \n    output$UI <- renderUI({\n      \n      if(!is.na(rev(dat$End)[1])){\n        # We now indicate what type of lure we use at the beginning of the session:\n        tagList(\n          selectInput(\"lure1\", \n                      label = \"Type de leurre\",\n                      choices = list(\"Shad\" = \"shad\",\n                                     \"Slug\" = \"slug\",\n                                     \"Jerkbait\" = \"jerkbait\",\n                                     \"Casting jig\" = \"jig\",\n                                     \"Topwater\" = \"topwater\"),\n                      selected = \"shad\",\n                      selectize = FALSE),\n          \n          selectInput(\"color_lure1\", \n                      label = \"Couleur du leurre\",\n                      choices = list(\"Naturel\" = \"naturel\",\n                                     \"Sombre\" = \"sombre\",\n                                     \"Clair\" = \"clair\",\n                                     \"Flashy\" = \"flashy\" ),\n                      selected = \"naturel\",\n                      selectize = FALSE),\n          \n          selectInput(\"length_lure1\",\n                      label = \"Taille du leurre\",\n                      choices = list(\"Petit\" = \"petit\",\n                                     \"Moyen\" = \"moyen\",\n                                     \"Grand\" = \"grand\"),\n                      selected = \"petit\",\n                      selectize = FALSE),\n          \n          actionButton(\"go\",\"Commencer session !\"))\n      }else{\n        \n        tagList(actionButton(\"go\",\"End session\"))\n      }\n      \n    })\n    \n    output$UI_sess <- renderUI({\n      \n      if(!is.na(rev(dat$End)[1])){\n        \n        tagList(textInput(\"comments\", label = \"Commentaire avant le début?\", value = \"NA\"))\n        \n      }else{\n        input$catch\n        input$lure\n        tagList(\n          \n          selectInput(\"lure_type\", \n                      label = \"Type de leurre\",\n                      choices = list(\"Shad\" = \"shad\",\n                                     \"Slug\" = \"slug\",\n                                     \"Jerkbait\" = \"jerkbait\",\n                                     \"Casting jig\" = \"jig\",\n                                     \"Topwater\" = \"topwater\"),\n                      selected = \"shad\",\n                      selectize = FALSE),\n          \n          selectInput(\"color_lure\", \n                      label = \"Couleur du leurre\",\n                      choices = list(\"Naturel\" = \"naturel\",\n                                     \"Sombre\" = \"sombre\",\n                                     \"Clair\" = \"clair\",\n                                     \"Flashy\" = \"flashy\" ),\n                      selected = \"naturel\",\n                      selectize = FALSE),\n          \n          selectInput(\"length_lure\",\n                      label = \"Taille du leurre\",\n                      choices = list(\"Petit\" = \"petit\",\n                                     \"Moyen\" = \"moyen\",\n                                     \"Grand\" = \"grand\"),\n                      selected = \"petit\",\n                      selectize = FALSE),\n          \n          actionButton(\"lure\",\n                       label = \"Changer de leurre!\"),\n          \n          br(), \n          br(), \n          \n          h4(\"Ajouter une capture\"),\n          \n          selectInput(\"species\", \n                      label = \"Espèces\",\n                      choices = list(\"Bar\" = \"bar\",\n                                     \"Bar moucheté\" = \"bar_m\",\n                                     \"Alose\" = \"alose\",\n                                     \"Maquereau\" = \"maquereau\",\n                                     \"Chinchard\" = \"chinchard\"),\n                      selected = \"bar\"),\n          \n          sliderInput(\"length\",\n                      label = \"Taille du poisson\",\n                      value = 25, \n                      min = 0, \n                      max = 80, \n                      step = 1),\n          \n          actionButton(\"catch\",\"Rajoutez cette capture aux stats!\"),\n          \n          br(), \n          br(), \n          \n          textInput(\"comments1\", label = h4(\"Commentaire avant la fin ?\"), value = \"NA\")\n        )\n      }\n    })\n  }, ignoreNULL = F)\n  \n  \n  #If the button is pushed, create the line to be added in the csv file. \n  \n  observeEvent(input$go,{\n    \n    # Two outcomes depending if the session starts or ends. This gives the possibility \n    # to the user to add a comment before starting the session or after ending the session\n    \n    if(!is.na(rev(dat$End)[1])){\n      \n      #Tide + geoloc + Weather\n      c_tide <- tide()\n      geoloc <- c(input$lat,input$long)\n      current.weather.info <- weather(lat = geoloc[1], lon = geoloc[2])\n      river.flow <- river_flow()\n      \n      n_ses <- c(rev(dat$Session)[1] + 1)\n      time_beg <- as.character(as.POSIXct(Sys.time()))\n      comment <- input$comments\n      dat.f <<- cbind(data.frame(n_ses,\n                                 time_beg,\n                                 NA,\n                                 geoloc[2],\n                                 geoloc[1]),\n                      current.weather.info,\n                      c_tide,\n                      river.flow,\n                      comment)\n      names(dat.f) <- names(dat)\n      print(dat.f)\n      final_dat <- rbind(dat, dat.f)\n      \n      lure <- drop_read_csv(\"/app_peche/lure.csv\",\n                            header = T,\n                            stringsAsFactors = F,\n                            dtoken = token)\n      \n      new_lure <- data.frame(n_ses = n_ses,\n                             time = as.character(as.POSIXct(Sys.time())),\n                             type_lure = input$lure1,\n                             color_lure = input$color_lure1,\n                             length_lure = input$length_lure1)\n      \n      new_df <- rbind(lure, \n                      new_lure)\n      \n      write_csv(as.data.frame(new_df), \"lure.csv\")\n      drop_upload(\"lure.csv\", path = \"App_peche\", mode = \"overwrite\", dtoken = token)\n      \n\n    }else{\n      \n      dat$End[nrow(dat)] <- as.character(as.POSIXct(Sys.time()))\n      dat$Comments[nrow(dat)] <- paste(dat$Comments[nrow(dat)], \"/\", input$comments1)\n      final_dat <- dat \n    }\n    \n    # Write csv in temporary files of shiny server \n    write_csv(as.data.frame(final_dat), \"session1.csv\")\n    \n    # Upload it to dropbox account \n    drop_upload(\"session1.csv\", path = \"App_peche\", mode = \"overwrite\", dtoken = token)\n  })\n  \n  # Add a line to the catch csv file whenever a fish is caught\n  observeEvent(input$catch,{\n    caugth <- drop_read_csv(\"/app_peche/catch1.csv\", header = T, stringsAsFactors = F, dtoken = token)\n    \n    catch <- data.frame(n_ses = dat$Session[nrow(dat)],\n                        time = as.character(as.POSIXct(Sys.time())),\n                        species = input$species,\n                        length = input$length)\n    \n    b <- rbind(caugth,catch)\n    \n    write_csv(as.data.frame(b), \"catch1.csv\")\n    drop_upload(\"catch1.csv\", path = \"App_peche\", mode = \"overwrite\", dtoken = token)\n  })\n  \n  \n  observeEvent(input$lure,{\n    lure <- drop_read_csv(\"/app_peche/lure.csv\",\n                          header = T,\n                          stringsAsFactors = F,\n                          dtoken = token)\n    \n    new_lure <- data.frame(n_ses = dat$Session[nrow(dat)],\n                        time = as.character(as.POSIXct(Sys.time())),\n                        type_lure = input$lure_type,\n                        color_lure = input$color_lure,\n                        length_lure = input$length_lure)\n    \n    new_df <- rbind(lure, \n               new_lure)\n    \n    write_csv(as.data.frame(new_df), \"lure.csv\")\n    drop_upload(\"lure.csv\", path = \"App_peche\", mode = \"overwrite\", dtoken = token)\n  })\n}\n```\n:::\n\n\n## Conclusion\n\nI have tested this new application during two fishing sessions and it has been working like a charm. I can't wait to present you my findings at the end of this fishing season ! \n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}