{
  "hash": "ec3b7fe6ef7e3f3535c123417408ddaf",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R et Shiny peuvent-ils faire de moi un meilleur pêcheur ? Partie 3\"\nsubtitle: \"Mise à jour de l'application\"\nauthor: \"Aurélien Callens\"\ndate: \"2021-06-01\"\nlang: fr\nexecute:\n  eval: false\ncategories:\n  - R\n  - Shiny\n  - Web scraping\n---\n\n\n\n\n\nDans cet [article précédent](../../posts/2020-09-12-datascience-fishing-part1), j'ai présenté l'application Shiny que j'ai développée pour enregistrer les données de mes sessions de pêche. Dans cet article, je vais présenter brièvement les modifications et les mises à jour que j'ai apportées pour améliorer l'application. Voici les principaux changements :\n\n+ **API Météo** : l'API que j'utilisais (Dark Sky) a arrêté de fournir des données gratuites. Je suis donc passé à [Openweathermap](https://openweathermap.org/) et j'ai dû mettre à jour les fonctions pour récupérer les mêmes informations qu'avant.\n\n+ **Débit de la rivière** : la première version de l'application ne collectait pas de données sur le débit de la rivière dans laquelle je pêche. Cependant, je suis convaincu que le débit de la rivière avant la session de pêche peut avoir un impact sur la présence de bar. J'ai donc créé une fonction de web scraping qui collecte les débits de la Nive et de l'Adour (les principales rivières où je pêche).\n\n+ **Collecte des données sur les leurres** : dans la première version, les données sur les leurres utilisés n'étaient collectées que lorsqu'un poisson était capturé. Cependant, je n'avais pas de données sur le temps que je passais à utiliser un leurre avant de capturer un poisson. La nouvelle version de l'application collecte maintenant des données sur le leurre et la fréquence à laquelle je change de leurre.\n\n## API Météo\n\nDe petites modifications ont été apportées pour adapter la fonction météo précédente à la nouvelle API météo. Comme cette nouvelle API ne fournit pas de données sur la phase de la lune, j'ai décidé de calculer la phase de la lune avec le package *oce* :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(tidyverse)\nlibrary(rvest)\nlibrary(oce)\n\nweather <- function(lat, lon, API_key){\n  url <- paste0(\"api.openweathermap.org/data/2.5/weather?lat=\", lat, \"&lon=\", lon, \"&appid=\", API_key, \"&units=metric\")\n  \n  rep <- GET(url)\n  \n  table <- fromJSON(content(rep, \"text\"))\n  \n  # The weather API don't provide moon phase so I compute it with Oce package\n  moon_phase <- round(moonAngle(t = Sys.Date(),\n                                longitude = as.numeric(lon),\n                                latitude = as.numeric(lat))$illuminatedFraction,\n                      3)\n  \n  \n  current.weather.info <- data.frame(Air_temp = table$main$temp,\n                                     Weather = table$weather$main,\n                                     Atm_pres = table$main$pressure,\n                                     Wind_str = table$wind$speed,\n                                     Wind_dir = table$wind$deg,\n                                     Cloud_cover = table$clouds$all,\n                                     PrecipInt = ifelse(is.null(table$rains$`1h`), 0, table$rains$`1h`),  \n                                     Moon = moon_phase)\n  return(current.weather.info)\n}\n```\n:::\n\n\n## Débit de la rivière\n\nJ'ai écrit des fonctions pour scrapper des informations sur les débits des rivières dans lesquelles je pêche le plus, sur un site web :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get and prepare the flow data\nget_Qdata <- function(link){\n  table <- fromJSON(content(GET(link), \"text\"))\n  table <- table$Serie$ObssHydro\n  table <- as.data.frame(table)\n  table$DtObsHydro <- sub(\"T\", \" \", table$DtObsHydro)\n  table$DtObsHydro <- substr(table$DtObsHydro, start = 1, stop = 19)\n  ts <- data.frame(Date = seq.POSIXt(as.POSIXct(range(table$DtObsHydro)[1],'%m/%d/%y %H:%M:%S'), \n                                     as.POSIXct(range(table$DtObsHydro)[2],'%m/%d/%y %H:%M:%S'), by=\"hour\"))\n  \n  table$DtObsHydro <- as.POSIXct(table$DtObsHydro, format = \"%Y-%m-%d %H:%M:%S\")\n  \n  table <- full_join(table, ts, by = c(\"DtObsHydro\" = \"Date\")) %>% arrange(DtObsHydro)\n  return(table)\n}\n\n# Main function to collect river flow \n\nriver_flow <- function(){\n  # Url of website to scrap:\n  url_index <- \"https://www.vigicrues.gouv.fr/services/station.json/index.php\"\n  \n  rep <- GET(url_index)\n  \n  table_index <- fromJSON(content(rep, \"text\"))$Stations%>% \n    na.omit()\n  \n  # I need to add the flow of several rivers to get the flow of the rivers I am interested in:\n  stations <- table_index %>% \n    filter(LbStationHydro %in% c(\"Pontonx-sur-l'Adour\", \"St-Pandelon\", \"Artiguelouve\", \"Escos\",\n                                 \"Aïcirits [St-Palais]\", \"Cambo-les-Bains\"))\n  \n  base_url <- \"http://www.vigicrues.gouv.fr/services/observations.json?CdStationHydro=\"\n  height_url <- \"&FormatDate=iso\"\n  Q_url <- \"&GrdSerie=Q\"\n  \n  stations <- stations %>% \n    mutate(WL_link = paste0(base_url, CdStationHydro, height_url),\n           Q_link = paste0(WL_link, Q_url))\n  \n  data_Q <- lapply(stations$Q_link, \n                   function(x){get_Qdata(x)})\n  \n  data_Q <- suppressWarnings(Reduce(function(...) merge(..., all = TRUE, by = \"DtObsHydro\"),\n                   data_Q))\n  \n  names(data_Q) <- c(\"Date\", stations$LbStationHydro) \n  \n  data_Q <- data_Q  %>% \n    mutate(hour_of_day = format(Date, \"%Y-%m-%d %H\"))\n  \n  \n  data_Q <- aggregate(.~hour_of_day, data = data_Q, mean, na.rm = TRUE, na.action = na.pass)\n  \n  data_Q <- imputeTS::na_interpolation(data_Q, option = \"linear\")\n  \n  final_data <- data_Q %>% \n    mutate(Adour = `Pontonx-sur-l'Adour` +  `Aïcirits [St-Palais]` + Artiguelouve + Escos + `St-Pandelon`,\n           Date = as.POSIXct(hour_of_day, tryFormats = \"%Y-%m-%d %H\")) %>% \n    select(Date, `Cambo-les-Bains`, Adour) %>% \n    rename(Nive = `Cambo-les-Bains`)\n  \n  Cur_flow <- data.frame(\"Nive_c\" = final_data[nrow(final_data), 2],\n                         \"Adour_c\" = final_data[nrow(final_data), 3])\n  \n  \n  final_data <- cbind(Cur_flow, final_data) %>% \n    nest(Ts_flow = c(Date, Nive, Adour)) %>% \n    mutate(Ts_flow = paste(Ts_flow))\n\n  return(final_data)\n}\n```\n:::\n\n\n## Application Shiny\n\nUn graphique simplifié de la nouvelle application est montré ci-dessous :\n\n\n\n\n\n![Graphique simplifié de la nouvelle application](images/graph_newapp.svg)\n\n\n### Côté UI\n\nLe côté UI n'a pas beaucoup changé, j'ai seulement supprimé l'onglet qui affichait les données de pêche sur une carte car je n'utilisais pas beaucoup cette fonctionnalité :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load libraries \nlibrary(shiny)\nlibrary(shinyWidgets)\nlibrary(googlesheets)\nlibrary(miniUI)\nlibrary(leaflet)\nlibrary(rdrop2)\nSys.setenv(TZ=\"Europe/Paris\")\n\n#Import the functions for weather API and webscrapping \nsuppressMessages(source(\"api_functions.R\"))\n\n\n# Load the dropbox token : \ntoken <<- readRDS(\"token.rds\")\n\n# Minipage for small screens\nui <- miniPage(tags$script('$(document).ready(function () {\n                           navigator.geolocation.getCurrentPosition(onSuccess, onError);\n\n                           function onError (err) {\n                           Shiny.onInputChange(\"geolocation\", false);\n                           }\n\n                           function onSuccess (position) {\n                           setTimeout(function () {\n                           var coords = position.coords;\n                           console.log(coords.latitude + \", \" + coords.longitude);\n                           Shiny.onInputChange(\"geolocation\", true);\n                           Shiny.onInputChange(\"lat\", coords.latitude);\n                           Shiny.onInputChange(\"long\", coords.longitude);\n                           }, 1100)\n                           }\n                           });'),\n               \n               gadgetTitleBar(\"Catch them all\", left = NULL, right = NULL),\n               \n               miniTabstripPanel(\n                 \n                 miniTabPanel(\"Session\", icon = icon(\"sliders\"),\n                              \n                              miniContentPanel(uiOutput(\"UI_sess\", align = \"center\"),\n                                               uiOutput(\"UI\", align = \"center\"))\n                              \n                 )\n               )\n               \n)\n```\n:::\n\n\n### Côté serveur\n\nPlusieurs changements ont été apportés du côté serveur pour collecter des données sur les leurres que j'utilise. Désormais, chaque fois que je change de leurre, je remplis un petit formulaire pour collecter les caractéristiques du leurre et cela ajoute une ligne dans un troisième fichier csv :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nserver <- function(input, output, session){\n  \n  observeEvent(input$go ,{\n    \n  # Read the csv file containing information about fishing session. If a session is running,\n  # display the UI that allows the user to input data about the fish caught. If a session is not started,\n  # display a button to start the session and small survey on lure characteristics.\n    \n    dat <<- drop_read_csv(\"/app_peche/session1.csv\", header = T, stringsAsFactors = F, dtoken = token)\n    \n    # Reactive UI\n    \n    output$UI <- renderUI({\n      \n      if(!is.na(rev(dat$End)[1])){\n        # We now indicate what type of lure we use at the beginning of the session:\n        tagList(\n          selectInput(\"lure1\", \n                      label = \"Type de leurre\",\n                      choices = list(\"Shad\" = \"shad\",\n                                     \"Slug\" = \"slug\",\n                                     \"Jerkbait\" = \"jerkbait\",\n                                     \"Casting jig\" = \"jig\",\n                                     \"Topwater\" = \"topwater\"),\n                      selected = \"shad\",\n                      selectize = FALSE),\n          \n          selectInput(\"color_lure1\", \n                      label = \"Couleur du leurre\",\n                      choices = list(\"Naturel\" = \"naturel\",\n                                     \"Sombre\" = \"sombre\",\n                                     \"Clair\" = \"clair\",\n                                     \"Flashy\" = \"flashy\" ),\n                      selected = \"naturel\",\n                      selectize = FALSE),\n          \n          selectInput(\"length_lure1\",\n                      label = \"Taille du leurre\",\n                      choices = list(\"Petit\" = \"petit\",\n                                     \"Moyen\" = \"moyen\",\n                                     \"Grand\" = \"grand\"),\n                      selected = \"petit\",\n                      selectize = FALSE),\n          \n          actionButton(\"go\",\"Commencer session !\"))\n      }else{\n        \n        tagList(actionButton(\"go\",\"End session\"))\n      }\n      \n    })\n    \n    output$UI_sess <- renderUI({\n      \n      if(!is.na(rev(dat$End)[1])){\n        \n        tagList(textInput(\"comments\", label = \"Commentaire avant le début?\", value = \"NA\"))\n        \n      }else{\n        input$catch\n        input$lure\n        tagList(\n          \n          selectInput(\"lure_type\", \n                      label = \"Type de leurre\",\n                      choices = list(\"Shad\" = \"shad\",\n                                     \"Slug\" = \"slug\",\n                                     \"Jerkbait\" = \"jerkbait\",\n                                     \"Casting jig\" = \"jig\",\n                                     \"Topwater\" = \"topwater\"),\n                      selected = \"shad\",\n                      selectize = FALSE),\n          \n          selectInput(\"color_lure\", \n                      label = \"Couleur du leurre\",\n                      choices = list(\"Naturel\" = \"naturel\",\n                                     \"Sombre\" = \"sombre\",\n                                     \"Clair\" = \"clair\",\n                                     \"Flashy\" = \"flashy\" ),\n                      selected = \"naturel\",\n                      selectize = FALSE),\n          \n          selectInput(\"length_lure\",\n                      label = \"Taille du leurre\",\n                      choices = list(\"Petit\" = \"petit\",\n                                     \"Moyen\" = \"moyen\",\n                                     \"Grand\" = \"grand\"),\n                      selected = \"petit\",\n                      selectize = FALSE),\n          \n          actionButton(\"lure\",\n                       label = \"Changer de leurre!\"),\n          \n          br(), \n          br(), \n          \n          h4(\"Ajouter une capture\"),\n          \n          selectInput(\"species\", \n                      label = \"Espèces\",\n                      choices = list(\"Bar\" = \"bar\",\n                                     \"Bar moucheté\" = \"bar_m\",\n                                     \"Alose\" = \"alose\",\n                                     \"Maquereau\" = \"maquereau\",\n                                     \"Chinchard\" = \"chinchard\"),\n                      selected = \"bar\"),\n          \n          sliderInput(\"length\",\n                      label = \"Taille du poisson\",\n                      value = 25, \n                      min = 0, \n                      max = 80, \n                      step = 1),\n          \n          actionButton(\"catch\",\"Rajoutez cette capture aux stats!\"),\n          \n          br(), \n          br(), \n          \n          textInput(\"comments1\", label = h4(\"Commentaire avant la fin ?\"), value = \"NA\")\n        )\n      }\n    })\n  }, ignoreNULL = F)\n  \n  \n  #If the button is pushed, create the line to be added in the csv file. \n  \n  observeEvent(input$go,{\n    \n    # Two outcomes depending if the session starts or ends. This gives the possibility \n    # to the user to add a comment before starting the session or after ending the session\n    \n    if(!is.na(rev(dat$End)[1])){\n      \n      #Tide + geoloc + Weather\n      c_tide <- tide()\n      geoloc <- c(input$lat,input$long)\n      current.weather.info <- weather(lat = geoloc[1], lon = geoloc[2])\n      river.flow <- river_flow()\n      \n      n_ses <- c(rev(dat$Session)[1] + 1)\n      time_beg <- as.character(as.POSIXct(Sys.time()))\n      comment <- input$comments\n      dat.f <<- cbind(data.frame(n_ses,\n                                 time_beg,\n                                 NA,\n                                 geoloc[2],\n                                 geoloc[1]),\n                      current.weather.info,\n                      c_tide,\n                      river.flow,\n                      comment)\n      names(dat.f) <- names(dat)\n      print(dat.f)\n      final_dat <- rbind(dat, dat.f)\n      \n      lure <- drop_read_csv(\"/app_peche/lure.csv\",\n                            header = T,\n                            stringsAsFactors = F,\n                            dtoken = token)\n      \n      new_lure <- data.frame(n_ses = n_ses,\n                             time = as.character(as.POSIXct(Sys.time())),\n                             type_lure = input$lure1,\n                             color_lure = input$color_lure1,\n                             length_lure = input$length_lure1)\n      \n      new_df <- rbind(lure, \n                      new_lure)\n      \n      write_csv(as.data.frame(new_df), \"lure.csv\")\n      drop_upload(\"lure.csv\", path = \"App_peche\", mode = \"overwrite\", dtoken = token)\n      \n\n    }else{\n      \n      dat$End[nrow(dat)] <- as.character(as.POSIXct(Sys.time()))\n      dat$Comments[nrow(dat)] <- paste(dat$Comments[nrow(dat)], \"/\", input$comments1)\n      final_dat <- dat \n    }\n    \n    # Write csv in temporary files of shiny server \n    write_csv(as.data.frame(final_dat), \"session1.csv\")\n    \n    # Upload it to dropbox account \n    drop_upload(\"session1.csv\", path = \"App_peche\", mode = \"overwrite\", dtoken = token)\n  })\n  \n  # Add a line to the catch csv file whenever a fish is caught\n  observeEvent(input$catch,{\n    caugth <- drop_read_csv(\"/app_peche/catch1.csv\", header = T, stringsAsFactors = F, dtoken = token)\n    \n    catch <- data.frame(n_ses = dat$Session[nrow(dat)],\n                        time = as.character(as.POSIXct(Sys.time())),\n                        species = input$species,\n                        length = input$length)\n    \n    b <- rbind(caugth,catch)\n    \n    write_csv(as.data.frame(b), \"catch1.csv\")\n    drop_upload(\"catch1.csv\", path = \"App_peche\", mode = \"overwrite\", dtoken = token)\n  })\n  \n  \n  observeEvent(input$lure,{\n    lure <- drop_read_csv(\"/app_peche/lure.csv\",\n                          header = T,\n                          stringsAsFactors = F,\n                          dtoken = token)\n    \n    new_lure <- data.frame(n_ses = dat$Session[nrow(dat)],\n                        time = as.character(as.POSIXct(Sys.time())),\n                        type_lure = input$lure_type,\n                        color_lure = input$color_lure,\n                        length_lure = input$length_lure)\n    \n    new_df <- rbind(lure, \n               new_lure)\n    \n    write_csv(as.data.frame(new_df), \"lure.csv\")\n    drop_upload(\"lure.csv\", path = \"App_peche\", mode = \"overwrite\", dtoken = token)\n  })\n}\n```\n:::\n\n\n## Conclusion\n\nJ'ai testé cette nouvelle application lors de deux sessions de pêche et elle fonctionne à merveille. J'ai hâte de vous présenter mes résultats à la fin de cette saison de pêche !\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}