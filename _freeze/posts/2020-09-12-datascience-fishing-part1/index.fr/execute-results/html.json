{
  "hash": "41a570ae39dae660a2f6e9e855399314",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R et Shiny peuvent-ils faire de moi un meilleur pêcheur ? Partie 1\"  \nsubtitle: \"Créer une application Shiny pour stocker mes données de pêche\"  \nauthor: \"Aurélien Callens\"\nlang: fr\ndate: \"2020-09-12\"\nmodified: \"2025-02-04\"\nexecute:\n  freeze: true\nimage: images/seabass_bay.jpg\ntoc: true\ncategories:\n  - R\n  - Shiny\n  - Web scraping\n---\n\n\n> **ℹ️ Note:**\n> Lorsque j’ai développé cette application, j’étais débutant en développement web et en gestion des données. J’ai choisi Shiny car c’était une solution simple pour moi à l’époque.  \n> Avec le recul, si je devais refaire ce projet aujourd’hui, j’opterais plutôt pour une application Django avec une base de données dédiée, ce qui offrirait plus de flexibilité et de robustesse.  \n\n\n\n\n\n\nMon passe-temps favori, en plus de R bien sûr, est la pêche. La plupart du temps, je pêche le bar (*Dicentrarchus labrax*) dans les estuaires. Le bar est un prédateur qui a un large éventail de proies : crabes, lançons, crevettes, gambas et autres poissons. Pour pêcher le bar, je n'utilise pas d'appâts vivants, je préfère utiliser des leurres artificiels qui imitent une proie spécifique.  \n\nEn théorie, attraper un poisson est assez simple :  \n\n  1. Utiliser un leurre qui imite la proie actuelle du bar.  \n\n  2. Animer le leurre dans une zone où les poissons sont actifs.  \n\n  3. Attraper un très gros poisson !  \n\nEn pratique, c'est une autre histoire ! En effet, l'activité alimentaire, la position du bar dans l'estuaire et ses proies varient en fonction de plusieurs paramètres :  \n\n  * Les caractéristiques du fond du fleuve, qui dépendent de l'endroit où je pêche.  \n  * L'heure de la journée : le bar est plus actif à l'aube et au crépuscule.  \n  * Le courant et le niveau d'eau associés à la marée. Le niveau d'eau dans les estuaires varie constamment en raison de l'influence des marées. Il est aussi influencé par le débit du fleuve, qui peut être plus élevé en cas de fortes pluies.  \n\nComme vous l'avez compris, de nombreux paramètres peuvent potentiellement influencer les résultats de mes sessions de pêche. C'est pourquoi j'ai décidé de créer une application Shiny pour augmenter le nombre et la taille des poissons capturés durant mes sessions. Pour atteindre cet objectif, je dois mieux comprendre l'activité, la position et les proies du bar en fonction des paramètres décrits ci-dessus.  \n\n## Exigences de mon application  \n\n  + Elle doit stocker les données de mes sessions de pêche :  \n\n| Informations nécessaires | Description des variables  | Source des données |\n|-|-|-|\n| Temps | Heure à laquelle un poisson est capturé, durée écoulée depuis le début de la session | R |\n| Prise | Espèce et taille du poisson capturé | Géolocalisation via smartphone ? |\n| Leurres | Type, longueur, couleur du leurre utilisé  | API météo |\n\n  + Elle doit enregistrer les données sur mes prises et les leurres artificiels utilisés :  \n\n| Informations nécessaires | Description des variables | Source des données |\n|-|-|-|\n| Temps | Heure à laquelle un poisson est capturé, durée écoulée depuis le début de la session | R |\n| Prise | Espèce et taille du poisson capturé | Saisie utilisateur |\n| Leurres | Type, longueur, couleur du leurre utilisé | Saisie utilisateur |\n\n  + Elle doit être adaptée aux petits écrans, car je l'utiliserai toujours sur mon téléphone.  \n\n  + Elle doit rester gratuite.  \n\n\n\n## Collecte des données  \n\n### Récupération de ma position GPS  \n\nMa position GPS est collectée grâce à un peu de code Javascript intégré dans l'en-tête de l'application Shiny. Ce code a été développé par AugusT et est disponible sur son <a href=\"https://github.com/AugustT/shiny_geolocation\" target=\"_blank\">dépôt GitHub</a>.  \n\n### API météo  \n\nPour les données météorologiques, j'ai trouvé une API gratuite appelée Dark Sky. J'ai développé une fonction qui prend en entrée les coordonnées d'un lieu ainsi que la clé utilisateur de l'API et retourne les conditions météorologiques actuelles sous forme de dataframe :  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(tidyverse)\nlibrary(rvest)\n\nweather <- function(x, API_key){\n  url <- paste0(\"https://api.darksky.net/forecast/\",API_key,\n                \"/\", x[1], \",\", x[2],\n                \"?units=ca&exclude=hourly,alerts,flags\")\n  \n  rep <- GET(url)\n  \n  table <- fromJSON(content(rep, \"text\"))\n  \n  current.weather.info <- with(table,\n                               data.frame(Air_temp = currently$temperature,\n                                     Weather = currently$summary,\n                                     Atm_pres = currently$pressure,\n                                     Wind_str = currently$windSpeed,\n                                     Wind_dir = currently$windBearing,\n                                     Cloud_cover = currently$cloudCover,\n                                     PrecipProb = currently$precipProbability,\n                                     PrecipInt = currently$precipIntensity,  \n                                     Moon = daily$data$moonPhase[1]))\n  return(current.weather.info)\n}\n```\n:::\n\n\n\n### Web scraping des données de marée  \n\nJ'ai créé une fonction pour récupérer des informations sur les marées à partir d'un site web français. La fonction suivante ne prend aucun argument et retourne le niveau d'eau actuel, l'état de la marée (montante ou descendante) ainsi que le temps écoulé depuis le dernier pic de marée pour le lieu où je pêche.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntide <- function(){\n  \n  # Set the current time and time zone \n  Sys.setenv(TZ=\"Europe/Paris\")\n  time <- as.POSIXct(Sys.time())\n  url <- \"https://services.data.shom.fr/hdm/vignette/grande/BOUCAU-BAYONNE?locale=en\"\n  \n  # Read the web page that contains the tide data \n  text <- url %>% \n    read_html() %>%\n    html_text()\n  \n  # Clean the html data to get a dataframe  with two cols Time and water level: \n\n  text <- as.character(sub(\".*var data = *(.*?) *\\\\;.*\", \"\\\\1\", text))\n  text <- unlist(str_split( substr(text, 1, nchar(text)-2), \"\\\\],\"))\n  tidy_df <- data.frame(hour=NA,Water=NA)\n  \n  for(i in 1:length(text)){\n    text_dat <- unlist(str_split(text[i], '\"'))[c(2,3)]\n    text_dat[1] <- substr(text_dat[1], 1, nchar(text_dat[1])-1)\n    text_dat[2] <- as.numeric(substr(text_dat[2], 2, nchar(text_dat[2])))\n    tidy_df[i,] <- text_dat\n  }\n  \n  tidy_df$hour <- as.POSIXct(paste(format(Sys.time(),\"%Y-%m-%d\"), tidy_df$hour))\n  \n  # Some lines to get the tide status (going down or up) : \n  \n  n_closest <- which(abs(tidy_df$hour - time) == min(abs(tidy_df$hour - time)))\n  \n  water_level <- as.numeric(tidy_df[n_closest, 2])\n  \n  all_decrea <- all(tidy_df$Water[(n_closest-6):(n_closest+6)] ==\n                      cummin(tidy_df$Water[(n_closest-6):(n_closest+6)] ))\n  \n  all_increa <- all(tidy_df$Water[(n_closest-6):(n_closest+6)] ==\n                      cummax(tidy_df$Water[(n_closest-6):(n_closest+6)] ))\n  \n  maree <- ifelse(all_decrea, \"Down\", ifelse(all_increa, \"Up\", \"Dead\"))\n  \n  \n  # Compute time since the last peak :\n  \n  last_peak <- max(cumsum(rle(diff(as.numeric(tidy_df$Water), lag = 2) > 0)$lengths)\n                   [cumsum(rle(diff(as.numeric(tidy_df$Water), lag = 2) >0)$lengths) < n_closest])\n  \n  \n  time_after <- as.numeric(difftime(tidy_df$hour[n_closest], tidy_df$hour[last_peak], units = \"mins\"))\n  \n  \n  # Return the list with the results :\n  \n  return(list(Water_level = water_level,\n              Maree = maree,\n              Time_peak = time_after))\n  \n}\n```\n:::\n\n\n\n## L'application Shiny  \n\nLe principal problème que j'ai rencontré lors du développement de cette application était le stockage des données. Shinyapps.io héberge gratuitement votre application Shiny, mais j'ai rencontré des problèmes lorsque j'ai utilisé l'application pour modifier les fichiers CSV.  \nLa solution que j'ai trouvée a été de stocker les données sur mon compte Dropbox. Vous pouvez trouver <a href=\"https://shiny.rstudio.com/articles/persistent-data-storage.html\" target=\"_blank\">ici</a> plus de détails sur le sujet ainsi que des solutions alternatives. J'ai utilisé le package *rdrop2* pour accéder et modifier les données via l'application Shiny.  \n\nVoici les principales étapes de cette application :  \n\n1. Au démarrage de l'application, un fichier CSV stocké sur mon Dropbox est lu afin de vérifier si une session de pêche est en cours ou non. Si ce n'est pas le cas, l'utilisateur peut démarrer une session de pêche.  \n\n2. Lors du démarrage d'une nouvelle session, une ligne contenant les coordonnées, les conditions météorologiques et les conditions de marée est ajoutée au fichier CSV mentionné précédemment.  \n\n3. Si un poisson est pêché, l'utilisateur peut remplir un formulaire pour enregistrer les données dans un second fichier CSV. Ce fichier contient : l'heure, l'espèce et la longueur du poisson ainsi que des informations sur le leurre utilisé (type, couleur, longueur).  \n\n4. L'utilisateur peut mettre fin à la session de pêche en appuyant sur un bouton. Cela enregistre l'heure de fin, les conditions météorologiques et les conditions de marée dans le premier fichier CSV.  \n\nUn schéma simplifié est présenté ci-dessous :  \n\n\n\n\n\n\n![Simplified workflow of the application](images/graph.svg)\n\n\n### Côté interface utilisateur (UI)  \n\nL'interface utilisateur de l'application est construite en utilisant le package *miniUI*. Ce package permet aux utilisateurs de R de développer des applications Shiny adaptées aux petits écrans.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load libraries \nlibrary(shiny)\nlibrary(shinyWidgets)\nlibrary(googlesheets)\nlibrary(miniUI)\nlibrary(leaflet)\nlibrary(rdrop2)\nSys.setenv(TZ=\"Europe/Paris\")\n\n#Import the functions for weather API and webscrapping \nsuppressMessages(source(\"api_functions.R\"))\n\n\n# Load the dropbox token : \ntoken <<- readRDS(\"token.rds\")\n\n# Minipage for small screens\nui <- miniPage(\n  # Javascript that give user location (input$lat,input$long)\n  tags$script('$(document).ready(function () {\n                           navigator.geolocation.getCurrentPosition(onSuccess, onError);\n                           \n                           function onError (err) {\n                           Shiny.onInputChange(\"geolocation\", false);\n                           }\n                           \n                           function onSuccess (position) {\n                           setTimeout(function () {\n                           var coords = position.coords;\n                           console.log(coords.latitude + \", \" + coords.longitude);\n                           Shiny.onInputChange(\"geolocation\", true);\n                           Shiny.onInputChange(\"lat\", coords.latitude);\n                           Shiny.onInputChange(\"long\", coords.longitude);\n                           }, 1100)\n                           }\n                           });'),\n  \n  gadgetTitleBar(\"Catch them all\", left = NULL, right = NULL),\n  \n  miniTabstripPanel(\n    #First panel depends if a fishing session is started or not \n    miniTabPanel(\"Session\", icon = icon(\"sliders\"),\n                 miniContentPanel(uiOutput(\"UI_sess\", align = \"center\"),\n                                  uiOutput(\"UI\", align = \"center\"))\n    ),\n    # Second panel displays the location of the previous fishing session with the number of fish caught \n    miniTabPanel(\"Map\", icon = icon(\"map-o\"),\n                 miniContentPanel(scrollable = FALSE,padding = 0,\n                                  div(style=\"text-align:center\",\n                                      prettyRadioButtons(\"radio\", inline = TRUE, label = \"\",\n                                                         choices = list(\"3 dernières sessions\" = 1,\n                                                                        \"3 Meilleures Sessions\" = 2,\n                                                                        \"Tout afficher\" = 3), \n                                                         selected = 1)),\n                                  leafletOutput(\"map\", height = \"93%\")\n                 ))\n  )\n  \n)\n```\n:::\n\n\n\n### Côté serveur  \n\nLe côté serveur est principalement composé de fonctions *observeEvent*. L'utilité de chaque *observeEvent* est indiquée dans le script sous forme de commentaires.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nserver <- function(input, output, session){\n  source(\"api_functions.R\")\n  \n  # Read the csv file containing information about fishing session. If a session is running,\n  # display the UI that allows the user to input data about the fish caught. If a session is not started,\n  # display a button to start the session.\n  \n  observeEvent(input$go ,{\n    \n    dat <<- drop_read_csv(\"/app_peche/session.csv\", header = T, stringsAsFactors = F, dtoken = token) \n    \n    output$UI<- renderUI({\n      tagList(\n        if(rev(dat$Status)[1] == \"end\"){\n          actionButton(\"go\",\"Start session\")}\n        else{\n          actionButton(\"go\",\"End session\") \n        }\n      )\n    })\n    \n    output$UI_sess<- renderUI({\n      if(rev(dat$Status)[1] == \"end\"){\n        tagList(textInput(\"comments\", label = h3(\"Commentaires\"), value = \"NA\"))\n      }else{\n        input$catch\n        \n        tagList(\n          selectInput(\"species\", label = h3(\"Espèces\"), \n                      choices = list(\"Bar\" = \"bar\", \n                                     \"Bar moucheté\" = \"bar_m\", \n                                     \"Alose\" = \"alose\",\n                                     \"Alose Feinte\" = \"alose_f\",\n                                     \"Maquereau\" = \"maquereau\", \n                                     \"Chinchard\" = \"chinchard\"), selected = \"bar\"),\n          \n          sliderInput(\"length\",label = h3(\"Taille du poisson\"),value=25,min=0,max=80, step=1),\n          \n          selectInput(\"lure\", label = h3(\"Type de leurre\"), \n                      choices = list(\"Shad\" = \"shad\",\n                                     \"Slug\" = \"slug\",\n                                     \"Jerkbait\" = \"jerkbait\",\n                                     \"Casting jig\" = \"jig\",\n                                     \"Topwater\" = \"topwater\"), selectize = FALSE),\n          \n          selectInput(\"color_lure\", label = h3(\"Couleur du leurre\"), \n                      choices = list(\"Naturel\" = \"naturel\",\n                                     \"Sombre\" = \"sombre\",\n                                     \"Clair\" = \"clair\",\n                                     \"Flashy\" = \"flashy\" ), selectize = FALSE),\n          \n          selectInput(\"length_lure\", label = h3(\"Taille du leurre\"), \n                      choices = list(\"Petit\" = \"petit\",\n                                     \"Moyen\" = \"moyen\",\n                                     \"Grand\" = \"grand\"), selectize = FALSE),\n          \n          actionButton(\"catch\",\"Rajoutez cette capture aux stats!\"),\n          \n          textInput(\"comments1\", label = h3(\"Commentaire avant la fin ?\"), value = \"NA\")\n          \n          \n        )\n        \n        \n      }\n      \n    })  \n    \n    \n  }, ignoreNULL = F)\n  \n  #If the button is pushed, create the line to be added in the csv file. \n  \n  observeEvent(input$go,{\n    \n    #Tide + geoloc + Weather\n    c_tide <- unlist(tide())\n    geoloc <- c(input$lat,input$long)\n    current.weather.info <- weather(geoloc) \n    \n    # Two outcomes depending if the session starts or ends. This gives the possibility \n    # to the user to add a comment before starting the session or after ending the session\n    \n    if(rev(dat$Status)[1] == \"end\"){\n      \n      n_ses <- c(rev(dat$Session)[1]+1)\n      stat_ses <- c(\"beg\")\n      time_beg <- as.character(as.POSIXct(Sys.time()))\n      comment <- input$comments\n      dat.f <- data.frame(n_ses, stat_ses, time_beg ,geoloc[2], geoloc[1], current.weather.info, c_tide[1], c_tide[2], c_tide[3], comment)\n      names(dat.f)<-names(dat)\n      a <- rbind(dat,dat.f)\n      \n    }else{\n      \n      n_ses <- c(rev(dat$Session)[1])\n      stat_ses <- c(\"end\")\n      time_beg <- as.character(as.POSIXct(Sys.time()))\n      comment1 <- input$comments1\n      dat.f<- data.frame(n_ses, stat_ses, time_beg ,geoloc[2], geoloc[1], current.weather.info, c_tide[1], c_tide[2], c_tide[3], comment1)\n      names(dat.f)<-names(dat)\n      a <- rbind(dat,dat.f)\n    }\n    \n    # Write csv in temporary files of shiny server \n    write_csv(as.data.frame(a), \"session.csv\")\n    \n    # Upload it to dropbox account \n    drop_upload(\"session.csv\", path = \"App_peche\", mode = \"overwrite\", dtoken = token)\n  })\n  \n  \n  # Add a line to the catch csv file whenever a fish is caught\n  observeEvent(input$catch,{\n    caugth <- drop_read_csv(\"/app_peche/catch.csv\", header = T, stringsAsFactors = F, dtoken = token) \n    \n    n_ses <- c(rev(dat$Session)[1])\n    time <- as.POSIXct(Sys.time())\n    time_after_beg <- round(as.numeric(difftime(time, rev(dat$Time)[1], units = \"mins\")), digits = 0)\n    \n    catch <- data.frame(n_ses, \n                        time = as.character(time),\n                        min_fishing = as.character(time_after_beg),\n                        species = input$species,\n                        length = input$length,\n                        lure = input$lure,\n                        colour = input$color_lure,\n                        length_lure = input$length_lure)\n    \n    b <- rbind(caugth,catch)\n    \n    # Write csv in temporary files of shiny server \n    write_csv(as.data.frame(b), \"catch.csv\")\n    # Upload it to dropbox account \n    drop_upload(\"catch.csv\", path = \"App_peche\", mode = \"overwrite\", dtoken = token)\n  })\n  \n  # Create the map with the results of previous session depending on the choice of the user :\n  \n  observeEvent(input$radio,{\n    \n    output$map <- renderLeaflet({\n      map_data <- map_choice(input$radio)\n      leaflet(map_data) %>% addTiles() %>%\n        addPopups(lng = ~Long,\n                  lat = ~Lat, \n                  with(map_data,\n                       sprintf(\"<b>Session %.0f : %.1f h</b> <br/> %s <br/> %.0f  poissons <br/> hauteur d'eau: %.0f m, %s, %.0f min après l'étal\",\n                               n_ses,\n                               duration,\n                               Time,\n                               nb,\n                               Water_level,\n                               Tide_status,\n                               Tide_time)),\n                  options = popupOptions(maxWidth = 100, minWidth = 50))\n    })\n    \n  })\n  \n}\n```\n:::\n\n\n## Conclusion et améliorations futures  \n\nVous pouvez trouver un exemple de démonstration de cette application (non connectée au compte Dropbox)  \n<a href=\"https://aureliencallens.shinyapps.io/Dummy_angler_app/\" target=\"_blank\">ici</a>.  \nJ’utilise cette application depuis un an sans aucun problème ! Les données que j’ai collectées seront présentées dans le prochain article.  \n\nDans les mois à venir, je dois trouver une nouvelle API gratuite pour remplacer l'actuelle. En effet, l’API météo que j’utilise a été rachetée par Apple et les requêtes gratuites seront arrêtées l’année prochaine.  \n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}